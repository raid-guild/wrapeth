{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nvar address_1 = require(\"./address\");\n\nvar bignumber_1 = require(\"./bignumber\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar utf8_1 = require(\"./utf8\");\n\nvar properties_1 = require(\"./properties\");\n\nvar errors = __importStar(require(\"./errors\"));\n\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexports.defaultCoerceFunc = function (type, value) {\n  var match = type.match(paramTypeNumber);\n\n  if (match && parseInt(match[2]) <= 48) {\n    return value.toNumber();\n  }\n\n  return value;\n}; ///////////////////////////////////\n// Parsing for Solidity Signatures\n\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n\n  return type;\n}\n\nfunction parseParam(param, allowIndexed) {\n  function throwError(i) {\n    throw new Error('unexpected character \"' + param[i] + '\" at position ' + i + ' in \"' + param + '\"');\n  }\n\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case '(':\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case ',':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        node.type = verifyType(node.type);\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== '') {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== '') {\n            if (allowIndexed && node.name === 'indexed') {\n              node.indexed = true;\n              node.name = '';\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case ']':\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n\n  delete parent.state;\n\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n} // @TODO: Better return type\n\n\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n\n      case '':\n        break;\n\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n\n  return abi;\n}\n\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null,\n    type: 'function'\n  };\n  var comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n\n  abi.name = left[1].trim();\n\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n\n      case 'payable':\n        abi.payable = true;\n        break;\n\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n\n      case '':\n        break;\n\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  }); // We have outputs\n\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n\n    if (right[1].trim() != '' || right[3].trim() != '') {\n      throw new Error('unexpected tokens');\n    }\n\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  return abi;\n}\n\nfunction parseParamType(type) {\n  return parseParam(type, true);\n}\n\nexports.parseParamType = parseParamType; // @TODO: Allow a second boolean to expose names\n\nfunction formatParamType(paramType) {\n  return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\n\nexports.formatParamType = formatParamType; // @TODO: Allow a second boolean to expose names and modifiers\n\nfunction formatSignature(fragment) {\n  return fragment.name + '(' + fragment.inputs.map(function (i) {\n    return formatParamType(i);\n  }).join(',') + ')';\n}\n\nexports.formatSignature = formatSignature;\n\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw new Error('unknown signature');\n}\n\nexports.parseSignature = parseSignature;\n\nvar Coder =\n/** @class */\nfunction () {\n  function Coder(coerceFunc, name, type, localName, dynamic) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  return Coder;\n}(); // Clones the functionality of an existing Coder, but without a localName\n\n\nvar CoderAnonymous =\n/** @class */\nfunction (_super) {\n  __extends(CoderAnonymous, _super);\n\n  function CoderAnonymous(coder) {\n    var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n\n    properties_1.defineReadOnly(_this, 'coder', coder);\n    return _this;\n  }\n\n  CoderAnonymous.prototype.encode = function (value) {\n    return this.coder.encode(value);\n  };\n\n  CoderAnonymous.prototype.decode = function (data, offset) {\n    return this.coder.decode(data, offset);\n  };\n\n  return CoderAnonymous;\n}(Coder);\n\nvar CoderNull =\n/** @class */\nfunction (_super) {\n  __extends(CoderNull, _super);\n\n  function CoderNull(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n  }\n\n  CoderNull.prototype.encode = function (value) {\n    return bytes_1.arrayify([]);\n  };\n\n  CoderNull.prototype.decode = function (data, offset) {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined)\n    };\n  };\n\n  return CoderNull;\n}(Coder);\n\nvar CoderNumber =\n/** @class */\nfunction (_super) {\n  __extends(CoderNumber, _super);\n\n  function CoderNumber(coerceFunc, size, signed, localName) {\n    var _this = this;\n\n    var name = (signed ? 'int' : 'uint') + size * 8;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n\n  CoderNumber.prototype.encode = function (value) {\n    try {\n      var v = bignumber_1.bigNumberify(value);\n      v = v.toTwos(this.size * 8).maskn(this.size * 8); //value = value.toTwos(size * 8).maskn(size * 8);\n\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n\n      return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n    } catch (error) {\n      errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: value\n      });\n    }\n\n    return null;\n  };\n\n  CoderNumber.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    var junkLength = 32 - this.size;\n    var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value)\n    };\n  };\n\n  return CoderNumber;\n}(Coder);\n\nvar uint256Coder = new CoderNumber(function (type, value) {\n  return value;\n}, 32, false, 'none');\n\nvar CoderBoolean =\n/** @class */\nfunction (_super) {\n  __extends(CoderBoolean, _super);\n\n  function CoderBoolean(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n  }\n\n  CoderBoolean.prototype.encode = function (value) {\n    return uint256Coder.encode(!!value ? 1 : 0);\n  };\n\n  CoderBoolean.prototype.decode = function (data, offset) {\n    try {\n      var result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value\n        });\n      }\n\n      throw error;\n    }\n\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero())\n    };\n  };\n\n  return CoderBoolean;\n}(Coder);\n\nvar CoderFixedBytes =\n/** @class */\nfunction (_super) {\n  __extends(CoderFixedBytes, _super);\n\n  function CoderFixedBytes(coerceFunc, length, localName) {\n    var _this = this;\n\n    var name = 'bytes' + length;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderFixedBytes.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      var data = bytes_1.arrayify(value);\n\n      if (data.length > 32) {\n        throw new Error();\n      }\n\n      result.set(data);\n    } catch (error) {\n      errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value\n      });\n    }\n\n    return result;\n  };\n\n  CoderFixedBytes.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n    };\n  };\n\n  return CoderFixedBytes;\n}(Coder);\n\nvar CoderAddress =\n/** @class */\nfunction (_super) {\n  __extends(CoderAddress, _super);\n\n  function CoderAddress(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n  }\n\n  CoderAddress.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n    } catch (error) {\n      errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: value\n      });\n    }\n\n    return result;\n  };\n\n  CoderAddress.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficuent data for address type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n    };\n  };\n\n  return CoderAddress;\n}(Coder);\n\nfunction _encodeDynamicBytes(value) {\n  var dataLength = 32 * Math.ceil(value.length / 32);\n  var padding = new Uint8Array(dataLength - value.length);\n  return bytes_1.concat([uint256Coder.encode(value.length), value, padding]);\n}\n\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 32) {\n    errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32))\n    });\n  }\n\n  var length = uint256Coder.decode(data, offset).value;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString()\n    });\n  }\n\n  if (data.length < offset + 32 + length) {\n    errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n    });\n  }\n\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length)\n  };\n}\n\nvar CoderDynamicBytes =\n/** @class */\nfunction (_super) {\n  __extends(CoderDynamicBytes, _super);\n\n  function CoderDynamicBytes(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n  }\n\n  CoderDynamicBytes.prototype.encode = function (value) {\n    try {\n      return _encodeDynamicBytes(bytes_1.arrayify(value));\n    } catch (error) {\n      errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value\n      });\n    }\n\n    return null;\n  };\n\n  CoderDynamicBytes.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n\n    result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n    return result;\n  };\n\n  return CoderDynamicBytes;\n}(Coder);\n\nvar CoderString =\n/** @class */\nfunction (_super) {\n  __extends(CoderString, _super);\n\n  function CoderString(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n  }\n\n  CoderString.prototype.encode = function (value) {\n    if (typeof value !== 'string') {\n      errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value: value\n      });\n    }\n\n    return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n  };\n\n  CoderString.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n\n    result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n    return result;\n  };\n\n  return CoderString;\n}(Coder);\n\nfunction alignSize(size) {\n  return 32 * Math.ceil(size / 32);\n}\n\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {// do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues = [];\n    coders.forEach(function (coder) {\n      arrayValues.push(values[coder.localName]);\n    });\n    values = arrayValues;\n  } else {\n    errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  if (coders.length !== values.length) {\n    errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = new Uint8Array(staticSize + dynamicSize);\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      //uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(dynamicOffset), offset);\n      offset += 32; //part.value.copy(data, dynamicOffset);  @TODO\n\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      //part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\n\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber()); // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n    }\n\n    if (result.value != undefined) {\n      value.push(result.value);\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  });\n  return {\n    value: value,\n    consumed: consumed\n  };\n}\n\nvar CoderArray =\n/** @class */\nfunction (_super) {\n  __extends(CoderArray, _super);\n\n  function CoderArray(coerceFunc, coder, length, localName) {\n    var _this = this;\n\n    var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    var dynamic = length === -1 || coder.dynamic;\n    _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n    _this.coder = coder;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderArray.prototype.encode = function (value) {\n    if (!Array.isArray(value)) {\n      errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value: value\n      });\n    }\n\n    var count = this.length;\n    var result = new Uint8Array(0);\n\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(count);\n    }\n\n    errors.checkArgumentCount(count, value.length, 'in coder array' + (this.localName ? \" \" + this.localName : \"\"));\n    var coders = [];\n\n    for (var i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n\n    return bytes_1.concat([result, pack(coders, value)]);\n  };\n\n  CoderArray.prototype.decode = function (data, offset) {\n    // @TODO:\n    //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n    var consumed = 0;\n    var count = this.length;\n\n    if (count === -1) {\n      try {\n        var decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value\n        });\n      }\n\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString()\n        });\n      }\n\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n\n    var coders = [];\n\n    for (var i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n\n    var result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderArray;\n}(Coder);\n\nvar CoderTuple =\n/** @class */\nfunction (_super) {\n  __extends(CoderTuple, _super);\n\n  function CoderTuple(coerceFunc, coders, localName) {\n    var _this = this;\n\n    var dynamic = false;\n    var types = [];\n    coders.forEach(function (coder) {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n\n      types.push(coder.type);\n    });\n    var type = 'tuple(' + types.join(',') + ')';\n    _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n    _this.coders = coders;\n    return _this;\n  }\n\n  CoderTuple.prototype.encode = function (value) {\n    return pack(this.coders, value);\n  };\n\n  CoderTuple.prototype.decode = function (data, offset) {\n    var result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderTuple;\n}(Coder);\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\n\n\nfunction splitNesting(value) {\n  var result = [];\n  var accum = '';\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n\n  result.push(accum);\n  return result;\n} // @TODO: Is there a way to return \"class\"?\n\n\nvar paramTypeSimple = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes\n};\n\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return new CoderTuple(coerceFunc, coders, localName);\n}\n\nfunction getParamCoder(coerceFunc, param) {\n  var coder = paramTypeSimple[param.type];\n\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n\n  var match = param.type.match(paramTypeNumber);\n\n  if (match) {\n    var size = parseInt(match[2] || \"256\");\n\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderNumber(coerceFunc, size / 8, match[1] === 'int', param.name);\n  }\n\n  var match = param.type.match(paramTypeBytes);\n\n  if (match) {\n    var size = parseInt(match[1]);\n\n    if (size === 0 || size > 32) {\n      errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderFixedBytes(coerceFunc, size, param.name);\n  }\n\n  var match = param.type.match(paramTypeArray);\n\n  if (match) {\n    var size = parseInt(match[2] || \"-1\");\n    param = properties_1.jsonCopy(param);\n    param.type = match[1];\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components, param.name);\n  }\n\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name);\n  }\n\n  errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type\n  });\n  return null;\n}\n\nvar AbiCoder =\n/** @class */\nfunction () {\n  function AbiCoder(coerceFunc) {\n    errors.checkNew(this, AbiCoder);\n\n    if (!coerceFunc) {\n      coerceFunc = exports.defaultCoerceFunc;\n    }\n\n    properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n  }\n\n  AbiCoder.prototype.encode = function (types, values) {\n    if (types.length !== values.length) {\n      errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n\n    var coders = [];\n    types.forEach(function (type) {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n      var typeObject = null;\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n  };\n\n  AbiCoder.prototype.decode = function (types, data) {\n    var coders = [];\n    types.forEach(function (type) {\n      // See encode for details\n      var typeObject = null;\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = properties_1.jsonCopy(type);\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n  };\n\n  return AbiCoder;\n}();\n\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();","map":{"version":3,"sources":["/Users/vengist/environments/raid/wethwrapper-web/node_modules/web3-eth-abi/node_modules/ethers/utils/abi-coder.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","__importStar","mod","__esModule","result","k","call","defineProperty","exports","value","address_1","require","bignumber_1","bytes_1","utf8_1","properties_1","errors","paramTypeBytes","RegExp","paramTypeNumber","paramTypeArray","defaultCoerceFunc","type","match","parseInt","toNumber","regexParen","regexIdentifier","verifyType","substring","parseParam","param","allowIndexed","throwError","i","Error","parent","name","state","allowType","node","length","c","allowParams","components","indexed","child","allowName","allowArray","sibling","push","readArray","parseSignatureEvent","fragment","abi","anonymous","inputs","trim","splitNesting","forEach","split","modifier","console","log","parseSignatureFunction","constant","outputs","payable","stateMutability","comps","left","right","parseParamType","formatParamType","paramType","getParamCoder","formatSignature","map","join","parseSignature","replace","Coder","coerceFunc","localName","dynamic","CoderAnonymous","_super","coder","_this","undefined","defineReadOnly","encode","decode","data","offset","CoderNull","arrayify","consumed","CoderNumber","size","signed","v","bigNumberify","toTwos","maskn","fromTwos","padZeros","error","INVALID_ARGUMENT","arg","coderType","hexlify","slice","junkLength","uint256Coder","CoderBoolean","reason","isZero","CoderFixedBytes","Uint8Array","set","CoderAddress","getAddress","_encodeDynamicBytes","dataLength","Math","ceil","padding","concat","_decodeDynamicBytes","toString","CoderDynamicBytes","CoderString","toUtf8Bytes","toUtf8String","alignSize","pack","coders","values","isArray","arrayValues","parts","index","staticSize","dynamicSize","part","dynamicOffset","unpack","baseOffset","CoderArray","count","checkArgumentCount","decodedLength","CoderTuple","types","accum","depth","paramTypeSimple","address","bool","string","bytes","getTupleParamCoder","component","jsonCopy","AbiCoder","checkNew","typeObject","defaultAbiCoder"],"mappings":"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","sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nvar address_1 = require(\"./address\");\nvar bignumber_1 = require(\"./bignumber\");\nvar bytes_1 = require(\"./bytes\");\nvar utf8_1 = require(\"./utf8\");\nvar properties_1 = require(\"./properties\");\nvar errors = __importStar(require(\"./errors\"));\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexports.defaultCoerceFunc = function (type, value) {\n    var match = type.match(paramTypeNumber);\n    if (match && parseInt(match[2]) <= 48) {\n        return value.toNumber();\n    }\n    return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = 'uint256' + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = 'int256' + type.substring(3);\n    }\n    return type;\n}\nfunction parseParam(param, allowIndexed) {\n    function throwError(i) {\n        throw new Error('unexpected character \"' + param[i] + '\" at position ' + i + ' in \"' + param + '\"');\n    }\n    var parent = { type: '', name: '', state: { allowType: true } };\n    var node = parent;\n    for (var i = 0; i < param.length; i++) {\n        var c = param[i];\n        switch (c) {\n            case '(':\n                if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n                node = node.components[0];\n                break;\n            case ')':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case ',':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var sibling = { type: '', name: '', parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case ' ':\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== '') {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== '') {\n                        if (allowIndexed && node.name === 'indexed') {\n                            node.indexed = true;\n                            node.name = '';\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case '[':\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case ']':\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        throw new Error(\"unexpected eof\");\n    }\n    delete parent.state;\n    if (allowIndexed && node.name === 'indexed') {\n        node.indexed = true;\n        node.name = '';\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\n// @TODO: Better return type\nfunction parseSignatureEvent(fragment) {\n    var abi = {\n        anonymous: false,\n        inputs: [],\n        name: '',\n        type: 'event'\n    };\n    var match = fragment.match(regexParen);\n    if (!match) {\n        throw new Error('invalid event: ' + fragment);\n    }\n    abi.name = match[1].trim();\n    splitNesting(match[2]).forEach(function (param) {\n        param = parseParam(param, true);\n        param.indexed = !!param.indexed;\n        abi.inputs.push(param);\n    });\n    match[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'anonymous':\n                abi.anonymous = true;\n                break;\n            case '':\n                break;\n            default:\n                console.log('unknown modifier: ' + modifier);\n        }\n    });\n    if (abi.name && !abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + abi.name + '\"');\n    }\n    return abi;\n}\nfunction parseSignatureFunction(fragment) {\n    var abi = {\n        constant: false,\n        inputs: [],\n        name: '',\n        outputs: [],\n        payable: false,\n        stateMutability: null,\n        type: 'function'\n    };\n    var comps = fragment.split(' returns ');\n    var left = comps[0].match(regexParen);\n    if (!left) {\n        throw new Error('invalid signature');\n    }\n    abi.name = left[1].trim();\n    if (!abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + left[1] + '\"');\n    }\n    splitNesting(left[2]).forEach(function (param) {\n        abi.inputs.push(parseParam(param));\n    });\n    left[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'constant':\n                abi.constant = true;\n                break;\n            case 'payable':\n                abi.payable = true;\n                break;\n            case 'pure':\n                abi.constant = true;\n                abi.stateMutability = 'pure';\n                break;\n            case 'view':\n                abi.constant = true;\n                abi.stateMutability = 'view';\n                break;\n            case '':\n                break;\n            default:\n                console.log('unknown modifier: ' + modifier);\n        }\n    });\n    // We have outputs\n    if (comps.length > 1) {\n        var right = comps[1].match(regexParen);\n        if (right[1].trim() != '' || right[3].trim() != '') {\n            throw new Error('unexpected tokens');\n        }\n        splitNesting(right[2]).forEach(function (param) {\n            abi.outputs.push(parseParam(param));\n        });\n    }\n    return abi;\n}\nfunction parseParamType(type) {\n    return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\nfunction formatParamType(paramType) {\n    return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n// @TODO: Allow a second boolean to expose names and modifiers\nfunction formatSignature(fragment) {\n    return fragment.name + '(' + fragment.inputs.map(function (i) { return formatParamType(i); }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\nfunction parseSignature(fragment) {\n    if (typeof (fragment) === 'string') {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n        fragment = fragment.trim();\n        if (fragment.substring(0, 6) === 'event ') {\n            return parseSignatureEvent(fragment.substring(6).trim());\n        }\n        else {\n            if (fragment.substring(0, 9) === 'function ') {\n                fragment = fragment.substring(9);\n            }\n            return parseSignatureFunction(fragment.trim());\n        }\n    }\n    throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\nvar Coder = /** @class */ (function () {\n    function Coder(coerceFunc, name, type, localName, dynamic) {\n        this.coerceFunc = coerceFunc;\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    return Coder;\n}());\n// Clones the functionality of an existing Coder, but without a localName\nvar CoderAnonymous = /** @class */ (function (_super) {\n    __extends(CoderAnonymous, _super);\n    function CoderAnonymous(coder) {\n        var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n        properties_1.defineReadOnly(_this, 'coder', coder);\n        return _this;\n    }\n    CoderAnonymous.prototype.encode = function (value) { return this.coder.encode(value); };\n    CoderAnonymous.prototype.decode = function (data, offset) { return this.coder.decode(data, offset); };\n    return CoderAnonymous;\n}(Coder));\nvar CoderNull = /** @class */ (function (_super) {\n    __extends(CoderNull, _super);\n    function CoderNull(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n    }\n    CoderNull.prototype.encode = function (value) {\n        return bytes_1.arrayify([]);\n    };\n    CoderNull.prototype.decode = function (data, offset) {\n        if (offset > data.length) {\n            throw new Error('invalid null');\n        }\n        return {\n            consumed: 0,\n            value: this.coerceFunc('null', undefined)\n        };\n    };\n    return CoderNull;\n}(Coder));\nvar CoderNumber = /** @class */ (function (_super) {\n    __extends(CoderNumber, _super);\n    function CoderNumber(coerceFunc, size, signed, localName) {\n        var _this = this;\n        var name = ((signed ? 'int' : 'uint') + (size * 8));\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.size = size;\n        _this.signed = signed;\n        return _this;\n    }\n    CoderNumber.prototype.encode = function (value) {\n        try {\n            var v = bignumber_1.bigNumberify(value);\n            v = v.toTwos(this.size * 8).maskn(this.size * 8);\n            //value = value.toTwos(size * 8).maskn(size * 8);\n            if (this.signed) {\n                v = v.fromTwos(this.size * 8).toTwos(256);\n            }\n            return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n        }\n        catch (error) {\n            errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: value\n            });\n        }\n        return null;\n    };\n    CoderNumber.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        var junkLength = 32 - this.size;\n        var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        else {\n            value = value.maskn(this.size * 8);\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, value),\n        };\n    };\n    return CoderNumber;\n}(Coder));\nvar uint256Coder = new CoderNumber(function (type, value) { return value; }, 32, false, 'none');\nvar CoderBoolean = /** @class */ (function (_super) {\n    __extends(CoderBoolean, _super);\n    function CoderBoolean(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n    }\n    CoderBoolean.prototype.encode = function (value) {\n        return uint256Coder.encode(!!value ? 1 : 0);\n    };\n    CoderBoolean.prototype.decode = function (data, offset) {\n        try {\n            var result = uint256Coder.decode(data, offset);\n        }\n        catch (error) {\n            if (error.reason === 'insufficient data for uint256 type') {\n                errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'boolean',\n                    value: error.value\n                });\n            }\n            throw error;\n        }\n        return {\n            consumed: result.consumed,\n            value: this.coerceFunc('bool', !result.value.isZero())\n        };\n    };\n    return CoderBoolean;\n}(Coder));\nvar CoderFixedBytes = /** @class */ (function (_super) {\n    __extends(CoderFixedBytes, _super);\n    function CoderFixedBytes(coerceFunc, length, localName) {\n        var _this = this;\n        var name = ('bytes' + length);\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.length = length;\n        return _this;\n    }\n    CoderFixedBytes.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            var data = bytes_1.arrayify(value);\n            if (data.length > 32) {\n                throw new Error();\n            }\n            result.set(data);\n        }\n        catch (error) {\n            errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: (error.value || value)\n            });\n        }\n        return result;\n    };\n    CoderFixedBytes.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n        };\n    };\n    return CoderFixedBytes;\n}(Coder));\nvar CoderAddress = /** @class */ (function (_super) {\n    __extends(CoderAddress, _super);\n    function CoderAddress(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n    }\n    CoderAddress.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n        }\n        catch (error) {\n            errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: value\n            });\n        }\n        return result;\n    };\n    CoderAddress.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficuent data for address type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n        };\n    };\n    return CoderAddress;\n}(Coder));\nfunction _encodeDynamicBytes(value) {\n    var dataLength = 32 * Math.ceil(value.length / 32);\n    var padding = new Uint8Array(dataLength - value.length);\n    return bytes_1.concat([\n        uint256Coder.encode(value.length),\n        value,\n        padding\n    ]);\n}\nfunction _decodeDynamicBytes(data, offset, localName) {\n    if (data.length < offset + 32) {\n        errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32))\n        });\n    }\n    var length = uint256Coder.decode(data, offset).value;\n    try {\n        length = length.toNumber();\n    }\n    catch (error) {\n        errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: length.toString()\n        });\n    }\n    if (data.length < offset + 32 + length) {\n        errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n        });\n    }\n    return {\n        consumed: 32 + 32 * Math.ceil(length / 32),\n        value: data.slice(offset + 32, offset + 32 + length),\n    };\n}\nvar CoderDynamicBytes = /** @class */ (function (_super) {\n    __extends(CoderDynamicBytes, _super);\n    function CoderDynamicBytes(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n    }\n    CoderDynamicBytes.prototype.encode = function (value) {\n        try {\n            return _encodeDynamicBytes(bytes_1.arrayify(value));\n        }\n        catch (error) {\n            errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'bytes',\n                value: error.value\n            });\n        }\n        return null;\n    };\n    CoderDynamicBytes.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n        return result;\n    };\n    return CoderDynamicBytes;\n}(Coder));\nvar CoderString = /** @class */ (function (_super) {\n    __extends(CoderString, _super);\n    function CoderString(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n    }\n    CoderString.prototype.encode = function (value) {\n        if (typeof (value) !== 'string') {\n            errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'string',\n                value: value\n            });\n        }\n        return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n    };\n    CoderString.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n        return result;\n    };\n    return CoderString;\n}(Coder));\nfunction alignSize(size) {\n    return 32 * Math.ceil(size / 32);\n}\nfunction pack(coders, values) {\n    if (Array.isArray(values)) {\n        // do nothing\n    }\n    else if (values && typeof (values) === 'object') {\n        var arrayValues = [];\n        coders.forEach(function (coder) {\n            arrayValues.push(values[coder.localName]);\n        });\n        values = arrayValues;\n    }\n    else {\n        errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    if (coders.length !== values.length) {\n        errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    var parts = [];\n    coders.forEach(function (coder, index) {\n        parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n    });\n    var staticSize = 0, dynamicSize = 0;\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            staticSize += 32;\n            dynamicSize += alignSize(part.value.length);\n        }\n        else {\n            staticSize += alignSize(part.value.length);\n        }\n    });\n    var offset = 0, dynamicOffset = staticSize;\n    var data = new Uint8Array(staticSize + dynamicSize);\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            //uint256Coder.encode(dynamicOffset).copy(data, offset);\n            data.set(uint256Coder.encode(dynamicOffset), offset);\n            offset += 32;\n            //part.value.copy(data, dynamicOffset);  @TODO\n            data.set(part.value, dynamicOffset);\n            dynamicOffset += alignSize(part.value.length);\n        }\n        else {\n            //part.value.copy(data, offset);  @TODO\n            data.set(part.value, offset);\n            offset += alignSize(part.value.length);\n        }\n    });\n    return data;\n}\nfunction unpack(coders, data, offset) {\n    var baseOffset = offset;\n    var consumed = 0;\n    var value = [];\n    coders.forEach(function (coder) {\n        if (coder.dynamic) {\n            var dynamicOffset = uint256Coder.decode(data, offset);\n            var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n            // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n            result.consumed = dynamicOffset.consumed;\n        }\n        else {\n            var result = coder.decode(data, offset);\n        }\n        if (result.value != undefined) {\n            value.push(result.value);\n        }\n        offset += result.consumed;\n        consumed += result.consumed;\n    });\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name) {\n            return;\n        }\n        if (name === 'length') {\n            name = '_length';\n        }\n        if (value[name] != null) {\n            return;\n        }\n        value[name] = value[index];\n    });\n    return {\n        value: value,\n        consumed: consumed\n    };\n}\nvar CoderArray = /** @class */ (function (_super) {\n    __extends(CoderArray, _super);\n    function CoderArray(coerceFunc, coder, length, localName) {\n        var _this = this;\n        var type = (coder.type + '[' + (length >= 0 ? length : '') + ']');\n        var dynamic = (length === -1 || coder.dynamic);\n        _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    CoderArray.prototype.encode = function (value) {\n        if (!Array.isArray(value)) {\n            errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'array',\n                value: value\n            });\n        }\n        var count = this.length;\n        var result = new Uint8Array(0);\n        if (count === -1) {\n            count = value.length;\n            result = uint256Coder.encode(count);\n        }\n        errors.checkArgumentCount(count, value.length, 'in coder array' + (this.localName ? (\" \" + this.localName) : \"\"));\n        var coders = [];\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return bytes_1.concat([result, pack(coders, value)]);\n    };\n    CoderArray.prototype.decode = function (data, offset) {\n        // @TODO:\n        //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n        var consumed = 0;\n        var count = this.length;\n        if (count === -1) {\n            try {\n                var decodedLength = uint256Coder.decode(data, offset);\n            }\n            catch (error) {\n                errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: error.value\n                });\n            }\n            try {\n                count = decodedLength.value.toNumber();\n            }\n            catch (error) {\n                errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: decodedLength.value.toString()\n                });\n            }\n            consumed += decodedLength.consumed;\n            offset += decodedLength.consumed;\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new CoderAnonymous(this.coder));\n        }\n        var result = unpack(coders, data, offset);\n        result.consumed += consumed;\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderArray;\n}(Coder));\nvar CoderTuple = /** @class */ (function (_super) {\n    __extends(CoderTuple, _super);\n    function CoderTuple(coerceFunc, coders, localName) {\n        var _this = this;\n        var dynamic = false;\n        var types = [];\n        coders.forEach(function (coder) {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        var type = ('tuple(' + types.join(',') + ')');\n        _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n        _this.coders = coders;\n        return _this;\n    }\n    CoderTuple.prototype.encode = function (value) {\n        return pack(this.coders, value);\n    };\n    CoderTuple.prototype.decode = function (data, offset) {\n        var result = unpack(this.coders, data, offset);\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderTuple;\n}(Coder));\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\nfunction splitNesting(value) {\n    var result = [];\n    var accum = '';\n    var depth = 0;\n    for (var offset = 0; offset < value.length; offset++) {\n        var c = value[offset];\n        if (c === ',' && depth === 0) {\n            result.push(accum);\n            accum = '';\n        }\n        else {\n            accum += c;\n            if (c === '(') {\n                depth++;\n            }\n            else if (c === ')') {\n                depth--;\n                if (depth === -1) {\n                    throw new Error('unbalanced parenthsis');\n                }\n            }\n        }\n    }\n    result.push(accum);\n    return result;\n}\n// @TODO: Is there a way to return \"class\"?\nvar paramTypeSimple = {\n    address: CoderAddress,\n    bool: CoderBoolean,\n    string: CoderString,\n    bytes: CoderDynamicBytes,\n};\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n    if (!components) {\n        components = [];\n    }\n    var coders = [];\n    components.forEach(function (component) {\n        coders.push(getParamCoder(coerceFunc, component));\n    });\n    return new CoderTuple(coerceFunc, coders, localName);\n}\nfunction getParamCoder(coerceFunc, param) {\n    var coder = paramTypeSimple[param.type];\n    if (coder) {\n        return new coder(coerceFunc, param.name);\n    }\n    var match = param.type.match(paramTypeNumber);\n    if (match) {\n        var size = parseInt(match[2] || \"256\");\n        if (size === 0 || size > 256 || (size % 8) !== 0) {\n            errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderNumber(coerceFunc, size / 8, (match[1] === 'int'), param.name);\n    }\n    var match = param.type.match(paramTypeBytes);\n    if (match) {\n        var size = parseInt(match[1]);\n        if (size === 0 || size > 32) {\n            errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderFixedBytes(coerceFunc, size, param.name);\n    }\n    var match = param.type.match(paramTypeArray);\n    if (match) {\n        var size = parseInt(match[2] || \"-1\");\n        param = properties_1.jsonCopy(param);\n        param.type = match[1];\n        return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n    }\n    if (param.type.substring(0, 5) === 'tuple') {\n        return getTupleParamCoder(coerceFunc, param.components, param.name);\n    }\n    if (param.type === '') {\n        return new CoderNull(coerceFunc, param.name);\n    }\n    errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n        arg: 'type',\n        value: param.type\n    });\n    return null;\n}\nvar AbiCoder = /** @class */ (function () {\n    function AbiCoder(coerceFunc) {\n        errors.checkNew(this, AbiCoder);\n        if (!coerceFunc) {\n            coerceFunc = exports.defaultCoerceFunc;\n        }\n        properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n    }\n    AbiCoder.prototype.encode = function (types, values) {\n        if (types.length !== values.length) {\n            errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        var coders = [];\n        types.forEach(function (type) {\n            // Convert types to type objects\n            //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n            //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = type;\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n    };\n    AbiCoder.prototype.decode = function (types, data) {\n        var coders = [];\n        types.forEach(function (type) {\n            // See encode for details\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = properties_1.jsonCopy(type);\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n    };\n    return AbiCoder;\n}());\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();\n"]},"metadata":{},"sourceType":"script"}